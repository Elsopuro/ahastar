\section{Related Work}
An annotation is simply a form of embedded domain knowledge that we store in our search graph and reference while computing a path plan. Such ideas are not new; some domain knowledge -- like terrain type --  is frequently pre-annotated into most grid maps. Terrain type annotations are useful because they allow us to determine which tiles are traversable by some class of agent and which are not and they are highly effective at pruning the search space for single-size agents. In our case, we would like to deal with with multi-sized agents that occupy several locations in the grid at once so the technique quickly breaks down if part of the agent overlaps a location which is not traversable. A simple solution to this problem, often seen in the entertaiment industry \cite{something}, is to avoid the problem altogether by increasing the resolution of the grid until the area inside each tile is large enough to accomodate the biggest agent in the environment. Unfortunately, this approach leads to coarse-grain plans that suffer from poor quality and, in the case of smaller agents, un-realistic movement stemming from too-early obstacle avoidance. A more promising approach is to create a multi-level grid; one for each size of agent. This ensures quality paths for all agents but leads to an exponential blow-up in memory as we increase the number and type of agents and sizes.

A very effective method for the efficient compuation of path planning solutions is to make the original problem more tractable by creating and searching within a smaller yet equivalent abstract space. Such hierarchical planning, involving the use of homomorphic abstraction, can be traced to \cite{holte96} and involves a four-step approach:
\begin{enumerate}
\item{Build an abstract state-space representation.}
\item{Determine the location of the initial and goal state in the abstract space.}
\item{Find the optimal path betwen then parent states of the initial and goal state. }
\item{If necessary, refine each step in the abstract plan by solving a smaller problem in the initial state space.}
\end{enumerate}
Our basic approach is identical to \cite{holte96} however we focus our efforts specifically on solving path planning problems rather than general search. \\ \newline 
Two recent hierarchial path planners that bear some resemblance to our work are describedin \cite{botea04} and \cite{sturtevant05}. The first of these, HPA*, performs grid-based decomposition of the search-space by dividing the environment into clusters and entrances which represent inter-cluster transitions. Planning involves inserting the low-level start and goal nodes into the abstract graph and finding the shortest path between them. 
PRA* on the other hand builds a multi-level search-space by abstracting cliques of nodes; the result is to narrow the search space in the original problem to a "window" of nodes along the optimal shortest-path.\newline
Both HPA* and PRA* are focused on solving planning problems for homogenous agents in homogenous-terrain environmnets and hence are not complete when either of these variables changes. We use clearance-value calculations to work out the size of the corridor connecting the start and goal nodes, thus guiding our search to only consider traversable locations. Our basic problem-solving approach however is quite similar to HPA*, which can be seen as a simplified version of AHA*. \\ \newline
One technique which bears some similarity to our work is the use of force potentials, frequently employed to help autonomous robots find a collision-free path through an environment. The basic intution is that a robot is attracted to the far-away goal and repulsed away from obstacles as it nears them. A well known method for calculating potentials is the Brushfire algorithm \cite{latombe91}, which proceeds by annotating each tile in a grid-map with the distance to the nearest obstacle. This embedded information allows the robot to calculate repulsive potentials and makes it possible to plan using gradient descent. \newline
Brushfire is similar to AHA* in that the annotations it produces allow an agent to know something about its proximity to a nearby obstacle. AHA* on the other hand explicitly calculates the maximal size of traversable space at each location. Furthermore, unlike Brushfire, AHA* does not suffer from incompleteness which can occur when repulsive forces cancel each other out and lead to the robot descending the gradient to a local minima.\\ \newline
The Corridor Map Method \cite{geraerts07} is a recently introduced path planner which also borrows heavily from the field of robotics. This technique involves building a \emph{probabilistic roadmap} to represent map connectivity. The roadmap (or backbone path) is comprised of nodes which are annotated with clearance information that indicates the radius of a maximally sized bounding sphere before an obstacle is encountered. A node on the backbone exists at every point where the topography of the map changes which allows the planner to answer queries for multi-size agents. Potential forces are used during path execution to refine the abstract plan and avoid dynamic obstacles. \newline
Similarities exist between AHA*'s approach to computing clearance and the CMM  method; both metrics are concerned with the amount of traversable space at a given location but our approach is adapted to grid environments and we compute a clearance value for each agent capability, making our method much more information rich. More significantly, our abstract graph annotation is not limited to specifying clearance at a fixed point; we annotate edges to indicate the terrain type and clearance of a corridor connecting two points not necessarily next to each other. \\ \newline
Representing an environment using navigation-meshes is increasingly popular in theliterature. Two recent planners in this category that bears some similarity to our workis Triangulation A* and Triangulation Reduction A* \cite{demyen07}. TA* makes use of a technique known as Delaunay triangulations to cover the environment with triangular polygons whose degrees are maximised. This results in an undirected graphconnected by constrained and unconstrained edges; the former being traversable and the latter not. TRA* is an extension of this approach that abstracts the triangle mesh into a structure resembling a roadmap. 
Like our approach, both TA* and TRA* are able to answer path queries for multi-size agents. In the case of TRA* the required clearance value to traverse a triangle is annotated into the edges connecting graph nodes; again, similar to our method. The abstraction approaches used by TA and TRA* are very distinctly different from our work; where we identify homogenous areas of terrain in order to build clusters their approach aims to maximise triangle size. We also have additional requirements to identify all possible transitions between two adjacent clusters; both TA* and TRA* assume a homogenous terrain.

